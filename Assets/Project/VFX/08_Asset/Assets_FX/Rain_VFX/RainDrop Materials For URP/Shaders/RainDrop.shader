//Material of the object with raindrop effect
Shader "Unlit/RainDrop"
{
    Properties
    {
        _DropTex("RainDrop Mask", 2D) = "white" {} //RainDrop Mask Texture,can be generated by CaptureNormal.cs
        _NoiseTex("Noise Texture", 2D) = "black" {} //Turbulence noise texture,used for distorting raindrops' moving direction
        _MainTex("Main Texture", 2D) = "white" {} //Albedo texture of the standard material
        _NormalMap("Normal Texture", 2D) = "bump" {} //Normal map of the standard material
        _MaskTex("Additional Mask Texture", 2D) = "white" {} //Rain drop mask texture, controls the weights of drips
        _AlbedoScale("Albedo Scale", Float) = 0.3 //Albedo intensity scale
        _TimeScale("Time Scale", Float) = 0.25 //The scale of the raindrops' sliding down speed
        _DropScale("Drop Scale", Float) = 1.0 //The scale of raindrops' size
        _TurbulenceScale("Turbulence Scale", Float) = 0.03 //The scale of turbulence texture, can control the frequency of raindrops' distortion
        _IndirectSpecularScale("Indirect Specular F90", Float) = 0.15 //This parameter controls the intensity of the environment specular when your view direction is parallel to the surface 
        _Translucency("Translucency", Float) = 0.5 //This parameter controls the translucency of raindrops.The surface behand raindrops will become darker when it is edited to a smaller value
        _SmoothnessAdd("Smoothness Scale", Float) = 0.2 //This parameter controls how much smoothness will be added to the surface behind raindrops
        _DropLightingScale("Drop Lighting Scale", Float) = 2.0 //This parameter controls the scale of raindrops' lighting
        _DotSize("Drop Dot Size", Float) = 0.6 //This parameter controls the size of "rain dots",which are some additional wet dots added to the horizontal surface
        _DotRepeat("Drop Dot Repeating", Float) = 40.0 //This parameter controls the repeating rate of rain dots. You can also use this parameter to alter the size of rain dots.
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            Name "ForwardLit"
            Tags { "LightMode" = "UniversalForward" }

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            //include the shader library of raindrop
            #include "RainDrop.hlsl"

            // Universal Pipeline keywords
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
            #pragma multi_compile _ SHADOWS_SHADOWMASK
            #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
            #pragma multi_compile_fragment _ _SHADOWS_SOFT
            #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3
            #pragma multi_compile_fragment _ _LIGHT_LAYERS
            #pragma multi_compile_fragment _ _LIGHT_COOKIES
            #pragma multi_compile _ _CLUSTERED_RENDERING
            #pragma shader_feature _ _DIRECTION_LERP //Enable Direction lerp or not
            #pragma shader_feature _ _DOT_ENABLE //Enable rain dot or not
            #pragma shader_feature _ _DRIP_ENABLE //Enable rain drip or not
            #pragma shader_feature _ _MASK_ENABLE //Enable mask texture or not

            struct appdata
            {
                float4 vertex : POSITION;
                half3 normal : NORMAL;
                half4 tangent : TANGENT;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float3 posWS : TEXCOORD1;
                half3 tangent : TEXCOORD2;
                half3 binormal : TEXCOORD3;
                half3 normal : TECOORD4;
                float3 viewDir : TEXCOORD5;
                half3 vertexSH : TEXCOORD6;
                float3 posTarget : TEXCOORD7;
                float3 normalTarget : REXCOORD8;
				//In the Direction Lerp mode, we need additional position and normal data
#ifdef _DIRECTION_LERP
                float3 posPrev : TEXCOORD9;
                float3 normalPrev : REXCOORD10;
#endif
                float4 vertex : SV_POSITION;
            };

            void OutputTangentToWorld(half4 vertexTangent, half3 vertexNormal, out half3 tangentWS, out half3 binormalWS, out half3 normalWS)
            {
                half sign = vertexTangent.w * GetOddNegativeScale();
                normalWS = TransformObjectToWorldNormal(vertexNormal);
                tangentWS = TransformObjectToWorldDir(vertexTangent.xyz);
                binormalWS = cross(normalWS, tangentWS) * sign;
            }

            float4 _MainTex_ST;

            v2f vert (appdata v)
            {
                v2f o;
                o.posWS = TransformObjectToWorld(v.vertex.xyz);
                o.vertex = TransformObjectToHClip(v.vertex.xyz);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                OutputTangentToWorld(v.tangent, v.normal.xyz, o.tangent.xyz, o.binormal.xyz, o.normal.xyz);
                o.viewDir = GetWorldSpaceViewDir(o.posWS);
                o.vertexSH = SampleSH(o.normal);
#ifdef _DIRECTION_LERP
                o.posTarget = mul(_TargetMatrix, float4(v.vertex.xyz, 1)).xyz;
                o.normalTarget = mul((float3x3)_TargetMatrix, v.normal.xyz);
                o.posPrev = mul(_PrevMatrix, float4(v.vertex.xyz, 1)).xyz;
                o.normalPrev = mul((float3x3)_PrevMatrix, v.normal.xyz);
#else
                o.posTarget = o.posWS;
                o.normalTarget = o.normal.xyz;
#endif
                return o;
            }

            //Albedo and normal maps for standard lighting
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            TEXTURE2D(_NormalMap);
            SAMPLER(sampler_NormalMap);

            //Mask Texture
            TEXTURE2D(_MaskTex);
            SAMPLER(sampler_MaskTex);

            float _AlbedoScale;

            half4 frag(v2f i) : SV_Target
            {
                //Preparing the Inputdata for standard lighting
                InputData inputData = (InputData)0;
                inputData.positionWS = i.posWS;

                i.tangent.xyz = normalize(i.tangent.xyz);
                i.binormal.xyz = normalize(i.binormal.xyz);
                i.normal.xyz = normalize(i.normal.xyz);
                // Extract the world position of object from matrix
                // We don't use this for now, if you wish the raindrops to follow the object when it is translated,
                // you could use this position to calculate a relative position, and use the relative position to get the drop mask. 
                //float3 worldPos = float3(UNITY_MATRIX_M[0][3], UNITY_MATRIX_M[1][3], UNITY_MATRIX_M[2][3]);

                //sample the tangent space normal
                half3 normalTS = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, i.uv).xyz;
                normalTS = normalize(normalTS * 2 - 1);

                inputData.tangentToWorld = half3x3((i.tangent.xyz), (i.binormal.xyz), (i.normal.xyz));
                inputData.normalWS = TransformTangentToWorld(normalTS, inputData.tangentToWorld);

                //Get the mask and normal of raindrop
                //See RainDrop.hlsl
#ifdef _DIRECTION_LERP
				//In the Direction Lerp mode, we calculate both previous and current drop mask and normal, then lerp between this 2 sets of values
                half3 dropNormalPrev;
                half dropMaskPrev = RainDropMask(i.posPrev, i.normalPrev, normalTS, inputData.normalWS, dropNormalPrev);
                half3 dropNormal;
                half dropMask = RainDropMask(i.posTarget, i.normalTarget, normalTS, inputData.normalWS, dropNormal);
                dropNormal = normalize(lerp(dropNormalPrev, dropNormal, _LerpWeight));
                dropMask = lerp(dropMaskPrev, dropMask, _LerpWeight);
#else
                half3 dropNormal;
                half dropMask = RainDropMask(i.posTarget, i.normalTarget, normalTS, inputData.normalWS, dropNormal);
#endif

#ifdef _MASK_ENABLE
                half mask = SAMPLE_TEXTURE2D(_MaskTex, sampler_MaskTex, i.uv).x;
                dropMask *= mask;
#endif
                
                inputData.viewDirectionWS = SafeNormalize(i.viewDir);
                //Calculate the ambient lighting
                //In this sample we didn't use lightmap, so just make the first parameter to be constant
                inputData.bakedGI = SAMPLE_GI(float2(0,0), i.vertexSH, inputData.normalWS);
                inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);
                
                //Normal specular for non metal materials
                half3 specular = half3(0.04, 0.04, 0.04);

                //Hard coded the basic smoothness to 0.5 in this demo
                //smoothness of the suface which behind raindrops will be scaled up by _SmoothnessAdd 
                half smoothness = 0.9;//0.5 * (1 + _SmoothnessAdd * dropMask.x);
                
                //sample standard albedo
                half4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _AlbedoScale;
                half3 diffuse = albedo.xyz;

                //Calculate Standard lighting
                //In this demo,we hard coded the metallic and emissive to 0,
                //and forced the alpha to be 1
                half4 oColor = UniversalFragmentPBR(inputData, diffuse, 0.0, specular,
                    smoothness, 1.0, half3(0.0, 0.0, 0.0), 1.0);

                //Then we calculate the lighting of raindrops layer
                inputData.normalWS = dropNormal;
                //Since we only need the specular lighting,just let the GI to be 0
                inputData.bakedGI = 0;
                //Force the diffuse and metallic to be 0 and
                //hard coded the smoothness to 0.9
                //Here we force the occlusion to be 0 because we want to calculate the indirect specular by ourself later
                half4 dropColor = UniversalFragmentPBR(inputData, 0.0, 0.0, half3(0.04, 0.04, 0.04),
                    0.9, 0, half3(0.0, 0.0, 0.0), 1.0);

                //Calculate the environment specular
                //The surface of raindrops can be treated as perfect smooth,
                //so we just need to deal with the fresnel term 
                half NoV = saturate(dot(inputData.viewDirectionWS, dropNormal));
                half3 reflectVector = reflect(-inputData.viewDirectionWS, dropNormal);
                //Sampling the cubemap
                half3 indirectSpecular = GlossyEnvironmentReflection(reflectVector, i.posWS, 0, 1.0h);
                //Use _IndirectSpecularScale to control the F90
                dropColor.xyz += F_Schlick(0.04, _IndirectSpecularScale, NoV) * indirectSpecular;
#if defined(_DOT_ENABLE) || defined(_DRIP_ENABLE)
                //Darken the surface behind raindrops based on _Translucency
                oColor.xyz *= (1 - dropMask.x * (1 - _Translucency));
                //Finally, adding dropColor to the color result
                //_DropLightingScale controls the lumninance of raindrops' lighting
                oColor.xyz += dropColor.xyz * dropMask.x * _DropLightingScale;
#endif
                //oColor.xyz += half3(0, max(0, dropMask.x * _DropLightingScale), 0);
                //oColor.xyz = dropNormal * 0.5 + 0.5;
                return oColor;
            }
            ENDHLSL
        }
        //some additional passes to adapt URP's shadow caster passs and depth only pass
        Pass
        {
            Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On
            ZTest LEqual
            ColorMask 0
            Cull[_Cull]

            HLSLPROGRAM
            #pragma exclude_renderers gles gles3 glcore
            #pragma target 4.5

                // -------------------------------------
                // Material Keywords
                #pragma shader_feature_local_fragment _ALPHATEST_ON
                #pragma shader_feature_local_fragment _GLOSSINESS_FROM_BASE_ALPHA

                //--------------------------------------
                // GPU Instancing
                #pragma multi_compile_instancing
                #pragma multi_compile _ DOTS_INSTANCING_ON

                // -------------------------------------
                // Universal Pipeline keywords

                // This is used during shadow map generation to differentiate between directional and punctual light shadows, as they use different formulas to apply Normal Bias
                #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW

                #pragma vertex ShadowPassVertex
                #pragma fragment ShadowPassFragment

                #include "Packages/com.unity.render-pipelines.universal/Shaders/SimpleLitInput.hlsl"
                #include "Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl"
                ENDHLSL
            }
        Pass
        {
            Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            HLSLPROGRAM
            #pragma exclude_renderers gles gles3 glcore
            #pragma target 4.5

            #pragma vertex DepthOnlyVertex
            #pragma fragment DepthOnlyFragment

            // -------------------------------------
            // Material Keywords
            #pragma shader_feature_local_fragment _ALPHATEST_ON
            #pragma shader_feature_local_fragment _GLOSSINESS_FROM_BASE_ALPHA

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            #pragma multi_compile _ DOTS_INSTANCING_ON

            #include "Packages/com.unity.render-pipelines.universal/Shaders/SimpleLitInput.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl"
            ENDHLSL
            }
    }

    CustomEditor "NekoPunch.Raindrop.RaindropShaderGUI"
}
